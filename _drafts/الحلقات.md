





## مثال: إيجاد أكبر عدد في قائمة من الأعداد

الآن سنرى برنامجاً يقوم بالبحث في قائمة من الأعداد لإيجاد أكبر عدد فيها. إذا كانت القائمة تحتوي على 10 عناصر، يمكنك بسهولة أن تنظر إليها وتجد أكبر رقم لكن ماذا لو كانت القائمة تحتوي على 1,000,000 عنصر؟ ستحتاج وقتاً طويلاً جداً لإيجاد أكبر رقم في هذه الحالة. لكن باستخدام بايثون يمكن إيجاد أكبر عدد خلال أقل من ثانية.

في المثال التالي يقوم البرنامج بالبحث عن أكبر عدد في قائمة تتكون من 5 أعداد موجبة. نفس البرنامج يمكن أن يستخدم مع قائمة فيها ألف عدد أو مليون عدد.

```python
largest = -1

for n in [2,6,912,77,13]:
  if n > largest:
    largest = n
    
print('Largest number is:', largest)
```

في السطر الأول نقوم بإنشاء متغير اسمه `largest` ونضع فيه عدداً سالباً وهو -1 (انتبه إلى إشارة السالب والتي تعني أن هذا العدد أقل من الصفر). هذا العدد نعرف أنه أقل من أي عدد موجود في القائمة التي نريد البحث فيها لأنها تحتوي على أعداد موجبة فقط كما قلنا.

بعد ذلك نأتي إلى حلقة `for`. سنمر في الحلقة على قائمة فيها 5 أعداد. سنأخذ كل عدد ونقارنه بالعدد المخزن في `largest`. إذا كان العدد أكبر من العدد المخزن في `largest` سيتم وضع هذا العدد في `largest` بدلاً من العدد المخزن مسبقاً. لتوضيح هذا دعونا نتتبع سير الحلقة.

في التكرار الأول للحلقة ستكون قيمة متغير الحلقة `n` تساوي 2 وهي قيمة العنصر الأول في القائمة. ثم سنبدأ بتنفيذ تعليمات الحلقة: لدينا في البداية شرط `if`. سنقارن `n` مع `largest`، نسأل: هل `n` أكبر من `largest`؟. في `n` لدينا 2 وفي `largest` لدينا -1. بالتأكيد 2 أكبر من -1، إذن جواب السؤال (جواب شرط `if`) سيكون `True` وسيتم تنفيذ التعليمة التابعة لـ `if` وبالتالي سيتم تخزين قيمة `n` داخل `largest`. إذن `largest` كان فيها -1 والآن أصبح فيها 2.

في التكرار الثاني للحلقة ستكون قيمة `n` تساوي 6 وسنعيد نفس الخطوات. سنبدأ بتنفيذ تعليمات الحلقة: سنقارن `n` مع `largest`، نسأل: هل `n` أكبر من `largest`؟. في `n` لدينا الآن 6 وفي `largest` لدينا 2. و 6 أكبر من 2، إذن جواب شرط `if` سيكون `True` وسيتم تنفيذ التعليمة التابعة لـ `if` وبالتالي سيتم تخزين قيمة `n` داخل `largest`. إذن `largest` كان فيها 2 والآن أصبح فيها 6.

في التكرار الثالث سنتبع نفس الخطوات. ستكون قيمة `n` في هذا التكرار 912. عندما نسأل هل `n` أكبر `largest` والذي قيمته الآن 6؟ سيكون الجواب `True` بالتأكيد وسيتم وضع 912 داخل `largest`.

في التكرار الرابع ستكون قيمة `n` تساوي 77. عندما نسأل في هذا التكرار هل `n` أكبر `largest` والذي قيمته الآن 912؟ سيكون الجواب `False` لأن 77 ليست أكبر من 912. إذن لن يتم تنفيذ التعليمة التابعة لـ  `if` في هذا التكرار وستبقى قيمة `largest` على ما هي عليه (912).

في التكرار الخامس والأخير ستكون قيمة `n` تساوي 13. عندما نسأل في هذا التكرار هل `n` أكبر `largest` والذي قيمته ما زالت 912؟ سيكون الجواب `False` لأن 13 ليست أكبر من 912. إذن لن يتم تنفيذ التعليمة التابعة لـ  `if` في هذا التكرار وستبقى قيمة `largest` على ما هي عليه (912).

الآن نكون قد انتهينا من حلقة `for` لأننا كررنا تنفيذ تعليمات الحلقة لكل عناصر القائمة. بعد حلقة `if` نجد أمر طباعة سيطبع التالي:

```
Largest number is 912
```

أي: "أكبر عدد هو 912"، لأن القيمة المخزنة في `largest` عند نهاية الحلقة كانت 912.

## مثال: جمع الأعداد الموجودة في قائمة

تخيل أن لديك قائمة فيها مليون عدد وتريد جمع هذه الأعداد. البرنامج التالي يقوم بذلك.

```python
import random
numbers = []
for i in range(1000000):
  random.seed(i)
  numbers.append(random.randint(1,300))
  
total = 0
for num in numbers:
  total = total + num
 
print('Total =', total)
```

الآن تجاهل الأسطر الأربعة الأولى في البرنامج. هذه الأسطر تقوم بتخزين مليون عدد في قائمة اسمها `numbers`. ستتعلم لاحقاً كيف تعمل هذه الأسطر الأربعة. نحن يهمنا في هذا البرنامج الأسطر التي بعدها والتي تجمع الأعداد الموجودة في `numbers`.

نبدأ بتعريف متغير اسمه `total` ونضع فيه 0. هذا المتغير سنخزن فيه مجموع الأعداد الموجودة في القائمة `numbers`. هذه القائمة تحتوي على مليون عدد. بعد ذلك تبدأ حلقة `for`. سنقوم بالمرور على المليون عنصر. في كل تكرار للحلقة سنمر على عنصر من العناصر، يعني الحلقة ستتكرر مليون مرة. في كل تكرار سنضيف قيمة العنصر إلى `total`.

لنفترض أن الأعداد الثلاثة الأولى في القائمة `numbers` هي 4 و 77 و 90.

في التكرار الأول ستكون قيمة متغير الحلقة `num` تساوي قيمة العنصر الأول في القائمة وهو 4. سيتم تنفيذ التعليمة الموجودة داخل الحلقة وهي إضافة قيمة `num` إلى `total`. في `total` لدينا الآن 0 وفي `num` لدينا 4. بعد تنفيذ التعليمة ستصبح قيمة `total` تساوي 0 + 4 أي 4.

في التكرار الثاني ستكون قيمة متغير الحلقة `num` تساوي قيمة العنصر الثاني في القائمة `numbers` وهو 77. سيتم تنفيذ التعليمة الموجودة داخل الحلقة وهي إضافة قيمة `num` إلى `total`. في `total` لدينا الآن 4 وفي `num` لدينا 77. بعد تنفيذ التعليمة ستصبح قيمة `total` تساوي 4 + 77 أي 81 وهو مجموع أول عنصرين في القائمة.

في التكرار الثالث سيتم إعادة نفس الخطوات وستصبح قيمة `total` في نهاية التكرار الثالث تساوي 81 + 90 أي 171 وهو مجموع أول ثلاثة عناصر في القائمة.

وسيتم تكرار الحلقة لبقية العناصر في القائمة `numbers` حتى نمر على جميع العناصر (مليون عنصر). بعد التكرار الأخير ستكون قيمة `total` تساوي مجموع المليون عدد الموجودة في القائمة `numbers`.

بعد حلقة `for` هناك تعليمة طباعة ستطبع مجموع الأعداد المخزن في `total`.

## مثال: البحث في قائمة عن قيمة معينة

لنفترض أن لديك قائمة فيها 100,000 عنصر. هذه العناصر هي أرقام الأطباء في مدينتك. والآن وجدت رقماً جديداً (0056284364) وتريد أن تعرف هل هو موجود في القائمة أم لا. بالطبع لن تبحث بنفسك لأن هذا صعب ويستغرق وقتاً طويلاً. لكن بما أنك تعرف الآن كيف تستخدم الحلقات في بايثون يمكنك كتابة برنامج بسيط يؤدي المهمة مثل التالي: 

```python
import random
import string
phone_numbers = []
for i in range(100000):
  random.seed(i)
  phone_numbers.append(
    ''.join(random.choices(string.digits, k=10)))

found = False
for v in phone_numbers:
  if v == '0056284364':
    found = True

print(found)
```

تجاهل الأسطر السبعة الأولى فهي تقوم بإنشاء قائمة وتخزين 100,000 رقم فيها، وفي هذه الأسطر أشياء لم نتعلمها بعد، فتجاهلها الآن. المهم أن بعد هذه الأسطر سيكون لدينا قائمة في متغير اسمه `phone_numbers` (يعني "أرقام الهواتف" بالعربية). في هذه القائمة 100,000 رقم هاتف.

نبدأ مع السطر التالي:

```python
found = False
```

هذا السطر فيه شيء جديد بالنسبة لنا. نعرف أننا نقوم بإنشاء متغير اسمه `found` (معنى found بالعربية "تم إيجاده") ولكننا هنا لا نضع فيه رقماً ولا سلسلة نصية، بل نضع فيه `False`. هل يمكن ذلك؟ نعم يمكن ذلك. هذا المتغير يسمى متغيراً منطقياً (boolean variable). هذا النوع من المتغيرات يمكن أن يحتوي على واحدة من قيمتين: إما `True` وإما `False`. ففي هذا السطر نضع قيمة `False` في هذا المتغير. سنرى بعد قليل ما معنى ذلك.

في السطر التالي نجد حلقة `for`. في هذه الحلقة نبحث في قائمة أرقام الهواتف عن الرقم الجديد الذي وجدناه. نفعل ذلك كالتالي: نمر على كل عنصر ونفحص العنصر: هل يساوي الرقم الذي نبحث عنه؟ إذا كان يساويه نضع `True` في المتغير `found` مما يعني أننا وجدنا العنصر. لكن إذا مررنا على كل العناصر ولم يكن أي عنصر يساوي الرقم الذي نبحث عنه ستبقى قيمة المتغير `found` كما هي (ستبقى `False`) مما يعني أن العنصر لم يتم إيجاده.

بعد الحلقة نطبع قيمة `found`. إن تم إيجاد العنصر سيتم طباعة "True" على الشاشة وإن لم يتم إيجاده سيتم طباعة "False".

 ## مثال: إيجاد أصغر عدد في قائمة

رأينا سابقاً كيف يمكننا إيجاد أكبر عدد في قائمة من الأعداد الموجبة:

```python
largest = -1

for n in [2,6,912,77,13]:
  if n > largest:
    largest = n
    
print('Largest number is:', largest)
```

الآن إذا أردنا إيجاد أصغر عدد في قائمة من الأعداد: كيف يمكننا فعل ذلك؟ هل يكفي تغيير إشارة < إلى >؟ بالطبع لا. في المثال أعلاه وضعنا عدداً سالباً (-1) في المتغير `largest` قبل بداية الحلقة لأننا نعرف أننا نبحث في قائمة من الأعداد الموجبة مما يجعل -1 أقل من أي عدد يمكن أن يكون في هذه القائمة. لكن الآن ما هي القيمة التي يجب استخدامها قبل الدخول في الحلقة؟ إذا استخدمنا -1 فالبرنامج لن يعمل بشكل صحيح لأن -1 قد تكون أصغر من كل الأعداد الموجودة في القائمة وبالتالي لن يتم إيجاد أصغر عدد في القائمة بشكل صحيح. ماذا لو استخدمنا 1000 مثلاً؟ أيضاً في هذه الحالة لن يعمل البرنامج بشكل صحيح عندما تكون هناك قيم الأعداد في القائمة كلها أكبر من 1000. إذن ماذا نفعل؟

يمكننا استخدام `None`. ذكرنا `None` سريعاً في السابق وقلنا أنها كلمة محجوزة في بايثون وتعني "لا شيء" وتستخدم للدلالة على عدم وجود شيء. سنستخدمها كما يلي:

```python
smallest = None

for n in [1,4,0,23,2000]:
  if smallest == None:
    smallest = n
  elif n < smallest:
    smallest = n
    
print('Smallest number is', smallest)
```

في السطر الأول وضعنا `None` في متغير اسمه `smallest` (معنى smallest بالعربية: الأصغر). ثم نأتي إلى حلقة `for`. سنمر على الأعداد في القائمة المعطاة بحثاً عن أصغر عدد. 

في التكرار الأول للحلقة ستكون قيمة متغير الحلقة `n` تساوي 1. سيتم تنفيذ التعليمات داخل الحلقة: في البداية لدينا جملة شرطية تسأل: هل قيمة المتغير `smallest` هي `None`؟ إذا كان جواب هذا السؤال `True` سيتم وضع قيمة `n` داخل `smallest` أما إذا كان الجواب `False` سيتم الانتقال إلى جملة `elif` والتي ستسأل: هل `n` أقل من `smallest`؟ هذا الجزء شبيه بمثال البحث عن أكبر عدد في الأعلى. إذا كان جواب هذا الشرط `True` سيتم وضع قيمة `n` داخل `smallest`. ففي التكرار الأول ستكون قيمة `smallest` هي `None` وبالتالي فإن شرط `if` سيتحقق وسيتم وضع قيمة `n` وهي 1 داخل `smallest` والانتقال للتكرار الثاني. 

في التكرار الثاني ستكون قيمة `n` تساوي 4 ولن يتحقق شرط `if` لأن `smallest` الآن تساوي 1 وليست `None` وكذلك لن يتحقق شرط `elif` لأن `n` وتساوي 4 ليست أصغر من `smallest` والتي تساوي 1، وسيتم بعدها الانتقال إلى التكرار الثالث.

في التكرار الثالث ستكون قيمة `n` تساوي 0 ولن يتحقق شرط `if` لأن `smallest` تساوي 1 وليست `None` ولكن سيتحقق شرط `elif` لأن `n` وتساوي 0 أصغر من `smallest` والتي تساوي 1، لذلك سيتم وضع قيمة `n` وهي 0 داخل `smallest`. وسيتم بعدها الانتقال إلى التكرار الرابع.

في التكرار الرابع ستكون قيمة `n` تساوي 23 ولن يتحقق شرط `if` لأن `smallest` ليست `None` وكذلك لن يتحقق شرط `elif` لأن `n` وتساوي 23 ليست أصغر من `smallest` والتي تساوي 0. وسيتم بعدها الانتقال إلى التكرار الخامس والأخير.

في التكرار الخامس ستكون قيمة `n` تساوي 2000 ولن يتحقق شرط `if` لأن `smallest` ليست `None` وكذلك لن يتحقق شرط `elif` لأن `n` وتساوي 2000 ليست أصغر من `smallest` والتي تساوي 0. الآن انتهت الحلقة. 

في النهاية يتم تنفيذ تعليمة الطباعة والتي ستطبع:

```
Smallest number is 0
```

وترجمة ذلك أن "أصغر عدد هو 0" وذلك لأن القيمة المخزنة في `smallest` عند نهاية الحلقة كانت 0.

إذن رأينا في هذا المثال كيف استخدمنا `None` لنتمكن من إيجاد أصغر عدد بشكل سليم. لاحظ أن هذا الجزء من الكود:

```python
if smallest == None:
    smallest = n
```

هو فقط وظيفته أن يضع أول عدد في القائمة داخل `smallest` في التكرار الأول للحلقة. لو حذفنا هذا الجزء سيحدث التالي: في التكرار الأول ستكون قيمة `smallest` هي `None` وعندما نصل لهذا الجزء (طبعاً سنستخدم `if` بدل `elif` لأننا حذفنا جملة `if`):

```python
elif n < smallest:
    smallest = n
```

سيحدث خطأ في تنفيذ البرنامج لأن قيمة `n` في هذا التكرار الأول ستكون 1 وقيمة `smallest` ستكون `None` كما قلنا، ولا يمكن مقارنة 1 مع `None`. يمكنك مقارنة عدد مع عدد أما مقارنة عدد مع `None` فلا معنى لها وستحدث خطأ في تنفيذ البرنامج. لهذا السبب استخدمنا هذا الكود:

```python
if smallest == None:
    smallest = n
```

ليتعامل مع الوضع في التكرار الأول.